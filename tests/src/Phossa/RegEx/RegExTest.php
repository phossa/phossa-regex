<?php
namespace Phossa\RegEx;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2015-11-23 at 06:39:31.
 */
class RegExTest extends \PHPUnit_Framework_TestCase
{
    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
    }

    /**
     * @covers Phossa\RegEx\RegEx::charWithExclusion
     */
    public function testCharWithExclusion1()
    {
        // match any single char but not 'x', 'xy', 'xyz'
        $regex = RegEx::charWithExclusion(['x', 'xy', 'xyz']);
        $pattern = Utility::toPattern($regex);

        // try 'x', fail
        $str1 = 'x';
        $this->assertEquals(0, preg_match_all($pattern, $str1, $m));

        // try 'y', match 'y'
        $str2 = 'y';
        $this->assertEquals(1, preg_match_all($pattern, $str2, $m));

        // try 'xy', fail
        $str3 = 'xy';
        $this->assertEquals(0, preg_match_all($pattern, $str3, $m));

        // try 'yx', match 'y'
        $str4 = 'yx';
        $this->assertEquals(1, preg_match_all($pattern, $str4, $m));

        // try 'xyx', fail
        $str5 = 'xyx';
        $this->assertEquals(0, preg_match_all($pattern, $str5, $m));

        // try 'xyz', fail
        $str6 = 'xyz';
        $this->assertEquals(0, preg_match_all($pattern, $str6, $m));

        // try 'xxyz', fail
        $str7 = 'xxyz';
        $this->assertEquals(0, preg_match_all($pattern, $str7, $m));

        // try 'x xyz', match ' '
        $str8 = 'x xyz';
        $this->assertEquals(1, preg_match_all($pattern, $str8, $m));
    }

    /**
     * @covers Phossa\RegEx\RegEx::charWithExclusion
     */
    public function testCharWithExclusion2()
    {
        // regex supplied
        $regex = RegEx::charWithExclusion(
            ['[x-z]'], [], RegExOption::OPTION_DEFAULT_REG
        );
        $pattern = Utility::toPattern($regex);

        // try 'x', fail
        $str1 = 'x';
        $this->assertEquals(0, preg_match_all($pattern, $str1, $m));

        // try 'x'yab, fail
        $str2 = 'xyab';
        $this->assertEquals(2, preg_match_all($pattern, $str2, $m));
    }

    /**
     * @covers Phossa\RegEx\RegEx::singleQuotedString
     */
    public function testSingleQuotedString()
    {
        // match single quote
        $regex = RegEx::singleQuotedString();
        $pattern = Utility::toPattern($regex);

        // normal string
        $str1 = "test 'one' 'two'";
        $this->assertEquals(2, preg_match_all($pattern, $str1, $m));
        $this->assertEquals("'two'", $m[0][1]);

        // span over lines
        $str2 = "test 'one' 'tw
        o'";
        $this->assertEquals(2, preg_match_all($pattern, $str2, $m));

        // allow no-closed match
        $str3 = "test 'one' 'two";
        $pattern3 = Utility::toPattern(RegEx::singleQuotedString(
            RegExOption::OPTION_DEFAULT ^ RegExOption::OPTION_CLOSURE
        ));
        $this->assertEquals(2, preg_match_all($pattern3, $str3, $m));
        $this->assertEquals("'two", $m[0][1]);

        // allow quote in quote
        $str4 = "test 'one \'two\'' 'three'";
        $this->assertEquals(2, preg_match_all($pattern, $str4, $m));
        $this->assertEquals("'one \'two\''", $m[0][0]);

        // test other quotes **
        $regex2 = RegEx::singleQuotedString(RegExOption::OPTION_DEFAULT, "**");
        $pattern2 = Utility::toPattern($regex2);

        $str5 = "**test** *wow* **bingo
            wo**  **x**";
        $this->assertEquals(3, preg_match_all($pattern2, $str5, $m));
        $this->assertEquals("**x**", $m[0][2]);

        // test non-literal
        $regex3 = RegEx::singleQuotedString(RegExOption::OPTION_DEFAULT_REG, "[a]");
        $pattern6 = Utility::toPattern($regex3);

        $str6 = "abca axa ax\aa";
        $this->assertEquals(3, preg_match_all($pattern6, $str6, $m));
        $this->assertEquals("ax\aa", $m[0][2]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::doubleQuotedString
     */
    public function testDoubleQuotedString()
    {
        // match double quote
        $regex = RegEx::doubleQuotedString();
        $pattern = Utility::toPattern($regex);

        // normal string
        $str1 = 'test "one" "two"';
        $this->assertEquals(2, preg_match_all($pattern, $str1, $m));
    }

    /**
     * @covers Phossa\RegEx\RegEx::quotedString
     */
    public function testQuotedString()
    {
        // pattern
        $regex = RegEx::quotedString(
            RegExOption::OPTION_DEFAULT ^ RegExOption::OPTION_CLOSURE
        );
        $pattern = Utility::toPattern($regex);

        // normal string
        $str1 = 'test \'single\' "double" \'single
        cross\' "double
        cross" "no close';
        $this->assertEquals(5, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('"no close', $m[0][4]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::unEscapedChar
     */
    public function testUnEscapedChar()
    {
        // pattern
        $regex = RegEx::unEscapedChar('[a-z]', RegExOption::OPTION_DEFAULT_REG);
        $pattern = Utility::toPattern($regex);

        // actually 'a \b \\c \\\d \\\\e'
        $str1 = 'a \b \\\c \\\\\d \\\\\\\e';
        $this->assertEquals(3, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('e', $m[0][2]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::escapedChar
     */
    public function testEscapedChar()
    {
        // pattern, non-literal input
        $regex = RegEx::escapedChar('[a-z]', RegExOption::OPTION_DEFAULT_REG);
        $pattern = Utility::toPattern($regex);

        // actually 'a \b \\c \\\d \\\\e'
        $str1 = 'a \b \\\c \\\\\d \\\\\\\e';
        $this->assertEquals(2, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('\d', $m[0][1]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::stringWithOpenClose
     */
    public function testStringWithOpenClose1()
    {
        // pattern
        $regex = RegEx::stringWithOpenClose('{*', '*}');
        $pattern = Utility::toPattern($regex);

        // test 1
        $str1 = '{* test *} {* wow *}';
        $this->assertEquals(2, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('{* wow *}', $m[0][1]);

        // test 2
        $str2 = '{* test {* wow *}';
        $this->assertEquals(1, preg_match_all($pattern, $str2, $m));
        $this->assertEquals('{* test {* wow *}', $m[0][0]);

        // cross line
        $str3 = '{* test
               wow *} ';
        $this->assertEquals(1, preg_match_all($pattern, $str3, $m));

        // wrap
        $str4 = '{* bingo {* wow *} test *}';
        $this->assertEquals(1, preg_match_all($pattern, $str4, $m));
        $this->assertEquals('{* bingo {* wow *}', $m[0][0]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::stringWithOpenClose
     */
    public function testStringWithOpenClose2()
    {
        // pattern, allow quoted substring & heredoc
        $regex = RegEx::stringWithOpenClose(
            '{*', '*}',RegExOption::OPTION_ALLOPTS
        );
        $pattern = Utility::toPattern($regex);

        // quoted substring
        $str1 = '{* test "*} {*" wow *}';
        $this->assertEquals(1, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('{* test "*} {*" wow *}', $m[0][0]);

        // quoted at front
        $str2 = '"{*" test {* wow *}';
        $this->assertEquals(1, preg_match_all($pattern, $str2, $m));
        $this->assertEquals('{* wow *}', $m[0][0]);

        // escaped
        $str3 = '{* test \*\} *}';
        $this->assertEquals(1, preg_match_all($pattern, $str3, $m));
        $this->assertEquals('{* test \*\} *}', $m[0][0]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::hereDoc
     */
    public function testHereDoc()
    {
        // pattern
        $regex = RegEx::hereDoc();
        $pattern = Utility::toPattern($regex);

        // test 1
        $str1 = '
    <<<EOF
        bingo
EOF;';
        $this->assertEquals(1, preg_match_all($pattern, $str1, $m));
    }

    /**
     * @covers Phossa\RegEx\RegEx::stringWithExclusion
     */
    public function testStringWithExclusion()
    {
        // pattern
        $regex = RegEx::stringWithExclusion(
            ['x', 'xx', 'xy', ','], RegExOption::OPTION_ALLOPTS
        );
        $pattern = Utility::toPattern($regex);

        // match only allowed
        $str1 = 'abcxokxyzz';
        $this->assertEquals(3, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('zz', $m[0][2]);

        // allow exclude in quoted substring
        $str2 = 'abc"x"abc';
        $this->assertEquals(1, preg_match_all($pattern, $str2, $m));
        $this->assertEquals('abc"x"abc', $m[0][0]);

        // used to split ',' but not split substring
        $str3 = 'a,b,"x,xy",c';
        $this->assertEquals(4, preg_match_all($pattern, $str3, $m));
        $this->assertEquals('"x,xy"', $m[0][2]);

        // test regex
        $regex2 = RegEx::stringWithExclusion(
            ['[,b]'],
            RegExOption::OPTION_ALLOPTS_REG
        );
        $pattern2 = Utility::toPattern($regex2);
        $this->assertEquals(3, preg_match_all($pattern2, $str3, $m));
        $this->assertEquals('"x,xy"', $m[0][1]);
    }

    /**
     * @covers Phossa\RegEx\RegEx::balancedString
     */
    public function testBalancedString()
    {
        // pattern
        $regex = RegEx::balancedString('{{', '}}');
        $pattern = Utility::toPattern($regex);

        // test 1
        $str1 = '{{x{y}} {z}} {{a {{bc}}';
        $this->assertEquals(2, preg_match_all($pattern, $str1, $m));
        $this->assertEquals('{{x{y}}', $m[0][0]);
        $this->assertEquals('{{bc}}', $m[0][1]);

        // quoted substring
        $str2 = '{{x "}}" y}} {{a}} {{ \'{{\' b}}';
        $this->assertEquals(3, preg_match_all($pattern, $str2, $m));
        $this->assertEquals('{{x "}}" y}}', $m[0][0]);
        $this->assertEquals('{{ \'{{\' b}}', $m[0][2]);

        // regex, { followed by char (not space)
        $regex2 = RegEx::balancedString(
            '{\S', '\S}', RegExOption::OPTION_ALLOPTS_REG
        );
        $pattern2 = Utility::toPattern($regex2);

        $str3 = '{bing} { x } {* wow *}';
        $this->assertEquals(2, preg_match_all($pattern2, $str3, $m));
        $this->assertEquals('{bing}', $m[0][0]);
        $this->assertEquals('{* wow *}', $m[0][1]);
    }
}
